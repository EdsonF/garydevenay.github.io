{"name":"GaryDevenay","tagline":"","body":"Writing unit tests for your Umbraco code has historically been a mean feat. Until 7.3 it has required that you build the Umbraco source from GitHub and reference the Umbraco.Tests.dll assembly.\r\n\r\nWith the launch of Umbraco 7.3, we now have the ability of creating mock implementations of our UmbracoContext and ApplicationContext objects that Umbraco requires to use certain objects that are common place in our controllers.\r\n\r\nI have recently released a small helper called [Umbraco Context Mock](https://github.com/garydevenay/GDev.Umbraco.Testing) that will help with the programming patterns that we are going to use to write testable Umbraco controllers, without deviating too far from our standard programming habbits.\r\n\r\n##Installing UmbracoContextMock\r\n\r\nI have added the UmbracoContextMock package to NuGet for ease of installing into your solutions. You will be required to install the package in both your Web and Tests project.\r\n\r\n`PM> Install-Package GDev.Umbraco.Testing`\r\n\r\nYou can also download and build the source from GitHub: https://github.com/garydevenay/GDev.Umbraco.Testing\r\n\r\n##Setting up our Controllers\r\n\r\nTypically our Umbraco controllers will be quite skinny, and we would like to keep it that way, so with the UmbracoContextMock (UCM) package we will only be adding three lines of code to enable us to write effective unit tests. Here is an example controller before our UCM changes:\r\n\r\n```C#\r\nusing System.Web.Mvc;\r\nusing Umbraco.Web;\r\n\r\nnamespace Umbraco.Example.Controllers\r\n{\r\n    public class HomeController : RenderMvcController\r\n    {\r\n        // GET: Home\r\n        public ActionResult Home()\r\n        {\r\n            var home = this.Umbraco.TypedContent(1);\r\n\r\n            return View(home);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nTo convert our controllers to be testable through the UCM helper, your controllers will start to looking something more like the following:\r\n\r\n```C#\r\nusing GDev.Umbraco.Testing.Controllers;\r\nusing System.Web.Mvc;\r\nusing Umbraco.Web;\r\n\r\nnamespace Umbraco.Example.Controllers\r\n{\r\n    public class HomeController : BaseRenderMvcController\r\n    {\r\n        public HomeController() { }\r\n        public HomeController(UmbracoContext context) : base(context) { }\r\n        public HomeController(UmbracoContext context, UmbracoHelper helper) : base(context, helper) { }\r\n\r\n        // GET: Home\r\n        public ActionResult Home()\r\n        {\r\n            var home = this.Umbraco.TypedContent(1);\r\n\r\n            return View(home);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe notable changes in our controllers would be that we are inheriting from BaseRenderMvcController rather than RenderMvcController. BaseRenderMvcController is a partial class which is part of the UCM helper. This is also the same convention for SurfaceController (**BaseSurfaceController**) and UmbracoApiController (**BaseUmbracoApiController**).\r\n\r\nThis partial class inherits from RenderMvcController itself, so we still have all the core benefits and future-proofing of the RenderMvcController, BaseRenderMvcController is merely a thin layer of functionality that is placed over RenderMvcController to allow us to inject our UmbracoContext and UmbracoHelper using constructor injection.\r\n\r\n##Writing a Unit Test\r\n\r\nWhen writing the unit tests for our applications, it is important that we plan the functionality for each controller before we rip in to programming. Writing your test suite before hand, and following Test Driven Development (TDD) practices is something that will help with this (and also ties in very nicely with the notion of Acceptance Criteria in agile methodologies).\r\n\r\nFor our first simple unit test, we will ensure that an instance of our controller and be instantiated whilst injecting our UmbracoContext and UmbracoHelper to our newly created constructor.  Your test will look something like the following.\r\n\r\n```C#\r\nusing System.Linq;\r\nusing System.Web.Security;\r\nusing NUnit.Framework;\r\nusing GDev.Umbraco.Testing;\r\nusing Umbraco.Example.Controllers;\r\nusing Umbraco.Web;\r\nusing Umbraco.Core.Models;\r\nusing Moq;\r\nusing Umbraco.Core.Dictionary;\r\nusing Umbraco.Core.Services;\r\nusing Umbraco.Web.Routing;\r\nusing Umbraco.Web.Security;\r\nusing System.Web.Mvc;\r\n\r\nnamespace Umbraco.Example.Tests.Controllers\r\n{\r\n    [TestFixture]\r\n    public class HomeControllerTests\r\n    {\r\n        private ContextMocker _mocker;\r\n\r\n        [SetUp]\r\n        public void SetUp()\r\n        {\r\n            this._mocker = new ContextMocker();\r\n        }\r\n\r\n        [Test]\r\n        public void CanInitializeRenderMvcController()\r\n        {\r\n            Assert.DoesNotThrow(() => new HomeController(this._mocker.UmbracoContextMock));\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAs you can see, we are only testing that we can create a new instance of our controller and inject our objects without any exceptions being thrown.\r\n\r\nAs our controller action is returning IPublishedContent, we can assume that our view is expecting IPublishedContent as it's model. From this assumption we can quickly draw the conclusion that if we return an object that is not an implementation of IPublishedContent our view will throw a YSOD.\r\n\r\nTo prevent this happening we can write a simple test:\r\n\r\n```C#\r\n[Test]\r\npublic void HomeDoesReturnIPublishedContent()\r\n{\r\n    UmbracoHelper helper = new UmbracoHelper(\r\n        this._mocker.UmbracoContextMock,\r\n        Mock.Of<IPublishedContent>(),\r\n        Mock.Of<ITypedPublishedContentQuery>(query => query.TypedContent(It.IsAny<int>()) == Mock.Of<IPublishedContent>(content => content.Id == 7)),\r\n        Mock.Of<IDynamicPublishedContentQuery>(),\r\n        Mock.Of<ITagQuery>(),\r\n        Mock.Of<IDataTypeService>(),\r\n        new UrlProvider(this._mocker.UmbracoContextMock, Enumerable.Empty<IUrlProvider>()),\r\n        Mock.Of<ICultureDictionary>(),\r\n        Mock.Of<IUmbracoComponentRenderer>(),\r\n        new MembershipHelper(this._mocker.UmbracoContextMock, Mock.Of<MembershipProvider>(), Mock.Of<RoleProvider>()));\r\n\r\n    var controller = new HomeController(this._mocker.UmbracoContextMock, helper);\r\n    ViewResult result = (ViewResult)controller.Home();\r\n\r\n    Assert.IsInstanceOf<IPublishedContent>(result.ViewData.Model);\r\n}\r\n```\r\n\r\nThis test will create a fake implementation of UmbracoHelper and pass that for our controller to use. The reason we should do this is that we only want to test a single unit of work and not the Umbraco core implementation of UmbracoHelper.\r\n\r\nAfter our UmbracoHelper fake is injected to our HomeController, the only thing we should now expect is that when we call the `Home()` action; the model that is returned should be of type IPublishedContent.\r\n\r\nFrom this point on we are able to start to plan our controller actions using unit tests and writing our functionality to pass those tests according to our acceptance criteria.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}